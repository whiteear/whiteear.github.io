<?xml version="1.0" encoding="utf-8"?>
  <rss version="2.0"
        xmlns:content="http://purl.org/rss/1.0/modules/content/"
        xmlns:atom="http://www.w3.org/2005/Atom"
  >
  <channel>
    <title>whiteear</title>
    <link href="http://whiteear.github.io//feed/" rel="self" />
    <link href="http://geeklu.com" />
    <lastBuildDate>2014-10-07T17:29:07+08:00</lastBuildDate>
    <webMaster>kejinlu@gmail.com</webMaster>
    
    <item>
      <title>提升使用VIM幸福感的几招</title>
      <link href="http://whiteear.github.io//2014/06/Private-Tips-to-Help-You-Using-vim/"/>
      <pubDate>2014-06-10T00:00:00+08:00</pubDate>
      <author>whiteear</author>
      <guid>http://whiteear.github.io//2014/06/Private-Tips-to-Help-You-Using-vim</guid>
      <content:encoded><![CDATA[<h2>引言</h2>

<blockquote><p>很多时候使用Vim的痛点在于有些操作总是不方便，不能流畅使用，本文是作者解决自己痛点时积累下来的，应该对其他人同样有用。
学习VIM的诀窍就是在用中学，所以您在看本文的时候最好打开VIM顺便实践一下。
由于本人需要同时使用众多的SERVER，不可能到处装插件，所以本文中所有的技巧都是VIM中自带的，不涉及插件。</p></blockquote>

<hr />

<h2>第一招，文件浏览类</h2>

<p><code>
:pwd
:cd
:e .
:Sex
:bro ol
</code></p>

<p>大多数VIM教程关注的都是文本编辑本身，所以如何方便的打开文件就被忽略了。
首先要明白VIM中有当前文件夹（CWD）的概念，默认是你打开VIM时所在的文件夹。你可以用与Linux一样的<code>:pwd</code>查看，
接下来你可以<code>:cd</code>到其他文件夹，再接下来就可以用<code>:e . (:edit .)</code>来浏览当前目录，vim会在一个新window中打开目录，你还可以进行查看父目录，排序等各种操作。这里顺便提一下用vim也可以打开各种压缩文件来查看目录结构。</p>

<p>上面的方式可以让你切换目录并打开文件。由于vim支持通过多窗口和多Tab同时编辑多个文件，假如你要不停的修改两个目录下的不同文件，那么用上面的方式不停的切换当前目录也是不方便的，是时候就轮到<code>:Sex</code>(或者:Sex!)了，它直接在新window中打开当前文件（而不是CWD）所在的目录，这样可你让你方便的浏览不同的目录。</p>

<p>同样是浏览目录，如果你用的是GUI版的vim，比如Windows版的GVIM，这时可以用<code>:bro e</code> （:browse explore）指令打开操作系统如Windows的文件浏览器。</p>

<p>最后一个快速打开文件的方法就是从编辑过的文件历史中选择，指令<code>:bro ol</code>（:browse old）可以打开编辑历史供你选择要打开的文件。</p>

<p>上面<code>:Sex</code>方式打开的文件是在一个Window里，如果你想在一个单独的Tab里编辑文件又该怎么办呢？<code>ctrol + w T</code>可以将当前的Window移动到一个新的Tab里。</p>

<h2>第二招，查看历史类</h2>

<p>使用vim时需要键入不少的指令，有些还相当的复杂，比如查找替换时用的正则表达式，上面提到过的历史编辑文件等。复用那些之前的指令可以大幅提升效率，各类常用查看历史的指令罗列如下：</p>

<p><code>
q/            查看搜索历史
q:            查看和执行历史指令，不可修改
:+up/down     查看指令历史，可修改       
:reg          查看剪贴板和宏历史
:marks        查看所有mark过的位置
</code></p>

<h2>第三招，另类搜索</h2>

<p>当一个patten的match太多的时候，用n在match中跳跃也比较费眼，这种情况我一般用<code>:vimgrep</code>，它可以把所有匹配显示在一个quickhelp窗口，然后你可以用<code>:cn</code> <code>:cp</code>等在结果中跳跃（也可用鼠标）。如果如果不需要跳转的话可以简单的键入<code>:g /patten</code>也会新开一个窗口并列出所有匹配。</p>

<p>```</p>

<p>:vimgrep patten %   %指当前文件名
:copen
:cn
:cp
:g /pattern</p>

<p>```</p>

<h2>其它提升幸福感的方法</h2>

<ol>
<li>使用<code>Ctrl+c</code>替代<code>ESC</code>。这是因为在Vi发明的时代ESC其实是在CapsLK的位置的，习惯<code>Ctrl+c</code>后会发现更幸福。</li>
<li>安装中文帮助文档，提升阅读文档的幸福感。</li>
<li>学习使用Shift键，比如<code>H</code> <code>J</code> <code>K</code> <code>L</code> <code>M</code> <code>I</code> <code>A</code> <code>O</code>等提升操作的流畅性。</li>
</ol>


<hr />

<blockquote><p>觉得本文还过得去的话，别忘了回到主页顺便看看作者的其它原创文章哟？</p></blockquote>
]]></content:encoded>
    </item>
    
    <item>
      <title>醉过方知酒浓，爱过方知情重－乱弹VIM与《红楼梦》</title>
      <link href="http://whiteear.github.io//2014/05/HongLouMeng-vim/"/>
      <pubDate>2014-05-24T00:00:00+08:00</pubDate>
      <author>whiteear</author>
      <guid>http://whiteear.github.io//2014/05/HongLouMeng-vim</guid>
      <content:encoded><![CDATA[<p>最近两个月都在过着有些不正常的生活。常常晚上11点后回到家，然后还要给国外开发团队发邮件，然后第二天一早起来先开电脑，再洗漱，再读邮件，再吃饭。在这种单调的生活中，唯一的娱乐就是在地铁时间读读《红楼梦》。《红楼梦》这书早些年尝试读过几次，当时要么是选几个热闹的地方读读，前后也连不起来，慢慢的就没了兴趣，最终都没有读下去。这次因为是用Kindle看，翻页不便，从前向后，果然竟读了下去，断断续续的读了两个多月，终于快把八十回读完了。这期间不时唏嘘感慨书中人物命运，又赞叹曹公的如椽巨笔，只将那些心酸与泪尽都藏在欢笑与荣耀之中，贵妃省亲时是何等的喜庆，偏却又是全书我看的最为心酸之处。现在想来，这一章节我十年前是无论如何读不出这个味道的。文学作品其实就是读者与主人公之间的共鸣，这才有了见山不是山或者见山是山之论。</p>

<p>再说VIM，第一次触是在十多年前。当时也就觉得是个难用的玩意，在05年接触Eclipse时却是极为震撼。时间变迁，VIM还那个VIM，Eclipse也还是那个Eclipse，我却慢慢发现Vim的好，甚至到了有些着迷的地步。Vim这个很多人觉得难学难用又过时的东西到底是那里好？其实它的深度与强大正是需要在使用中一点一滴的去感受，一定要先经历长时间的一段枯燥难用期，才能修成正果。正如《红楼梦》写的都是又平常又荒唐的场景，曹公既不对人生发问，也不对其作答，更不评论，就是一个个场景的描绘，似乎平谈难读，非要你不停的思考才明白其中的深意。</p>

<p>曲高就易和寡，好东西往往是深藏不露。Vim超高的学习曲线，《红楼梦》的伏脉千里，使得多数人见山不是山。技术与人生也相通，发现身边的美好，且行且珍稀才是正道理。</p>
]]></content:encoded>
    </item>
    
    <item>
      <title>为什么要学习VIM</title>
      <link href="http://whiteear.github.io//2014/04/Reasons-to-Learn-vim/"/>
      <pubDate>2014-04-19T00:00:00+08:00</pubDate>
      <author>whiteear</author>
      <guid>http://whiteear.github.io//2014/04/Reasons-to-Learn-vim</guid>
      <content:encoded><![CDATA[<blockquote><p>Vim很多很多年前就接触过，但是一直就把它当成过时的一塌糊涂的玩意，没把它当回事。直到最近在Linux上的工作越来越多，又在stackoverflow上见到众多其粉丝的高度评价后才
将信将疑开始学习，结果重度沉迷其中，不可自拔，上个周末读其帮助文档读到半夜，到底是什么在吸引我呢？</p></blockquote>

<h3>一切都由快捷键实现</h3>

<p>有没有快捷键情节可以决定一个人是否适合学习vim。以我为例，当年学photoshop时几乎学会了其全部快捷键，最近开始用visual studio，也是先花半天学习快捷键。想想看vim的命
令模式不就全是快捷键吗？默认的加上自定义的，在数量上可以轻松超过300个，再加上其快捷键可以组合使用，比如y,G,p各自是快捷键，组合起来的yyGp是将当前行复制粘贴到文件尾，这是一个何等强大的快捷键系统！</p>

<h3>更高效的焦点移动</h3>

<p>大多数人都不相信用键盘移动焦点会快过鼠标。这一段时间我各种编辑器混着用，总的感觉是少数情况下鼠标快，综合考虑Vim命令模式快。</p>

<h3>功能强大</h3>

<p>什么叫功能强大？本人用了十年的Eclipse也算的上熟练吧。Eclipse中喜欢用的快捷键有Alt加上下移动选中的行，Ctrl加上下键移动可视区域(View port)但不改变光标位置，在上次编辑位置中来回跳等。最近用的Visual Studio 2010中有个用绿色和黄色指示当前编辑过的行的功能，这一点我比较喜欢。但是上面这些功能在VIM这里全部都有，由此可见VIM功能之全面。个人以为仅以编辑器的功能来说vim是主流IDE的超集。</p>

<p>当然了这里也要客观得提一下vim在语言相关的功能上并不能全面压倒IDE，比如Java语言的静态语法错误检测，各种重构，搜索方法的调用层级，accesser自动生成等。但是动态语言的IDE并不具有上述功能(python，PHP等)，此时vim占据较大优势。对于静态语言来说，当改Bug查代码为主要任务时，Vim也是非常合适的。</p>

<h3>一次学习终身受用</h3>

<p>在Linux中应用广泛，可跨平台到Windows, Mac，提供一致性的使用体验 。
Linux发行版中普遍包含，在服务器上调试脚本必不可少。
在Linux常用命令中普遍出现，如git，less，man需要移动和翻页时都可以用vi的方式。</p>

<h3>入门难精通快</h3>

<p>vim难学，主要体现在人们无法适应没有鼠标的感觉，也无法相信不用鼠标可以更快，然后采用死记硬背的方式来记快捷键，既没信心又没方法。
这里建议大家用分级学习的方法，先明确目标，<strong>然后要在用中学</strong>，万不可死记硬背。我的分级如下。</p>

<p><strong>第一级是基本概念</strong></p>

<p>Vim中自带了vim tutor学习教程，会指导你边学边做，学习最基本的移动，复制粘贴等，每遍30分钟左右，两三遍后这一级就过了。这时Windows的Notpad就被打败了。</p>

<p><strong>第二级是高级光标移动和复制粘贴</strong></p>

<p>熟练的光标移动非常重要，这一部分学好了编辑效率会直线提升，摆脱心理上对鼠标的依赖。
建议直接学习自带的帮助中的motion一章，输入:h motion即可。
复制粘贴是与选择相关的，高效的复制粘贴掌握后就可以不再依赖Notepad++之类的较高级的编辑器了。</p>

<p><strong>第三级是持续改进级</strong></p>

<p>不断使用，不断发掘，不断熟练。</p>
]]></content:encoded>
    </item>
    
    <item>
      <title>git merge --squash and git rebase explained</title>
      <link href="http://whiteear.github.io//2014/03/Git_merge_--squash_and_git_rebase/"/>
      <pubDate>2014-03-17T00:00:00+08:00</pubDate>
      <author>whiteear</author>
      <guid>http://whiteear.github.io//2014/03/Git_merge_--squash_and_git_rebase</guid>
      <content:encoded><![CDATA[<blockquote><p>One advantage for Git comes from its powerful branch management capability, but it will be hard to maintain the commit history between different branches. As Linus said that <a href="http://blog.sevenche.com/2014/02/Linus-Torvalds-rules-for-using-Git/">Clear and Clean is important for the commit history</a>, here in this article I am going to demonstrate how <code>git merge --squash</code>, <code>git merge</code>, and <code>git rebase</code> will affect the commit history.</p></blockquote>

<h3><code>git merge</code> and <code>git merge --squash</code></h3>

<p>In below example I am going to merge <code>dev3</code> into <code>dev2</code> and <code>dev4</code> by using merge with and without <code>--squash</code> parameter.</p>

<p><strong> Initial status </strong></p>

<p><img src="/media/pic2014/0317-2.png" alt="" /></p>

<p><strong>merge with <code>--squash</code> test</strong></p>

<p><code>
git checkout dev4
git merge --squash dev3
git commit -a
</code></p>

<p><img src="/media/pic2014/0317-3.png" alt="git merge" /></p>

<p>We can see changed files in working directory and after commit we don't see <code>fbcb87a</code> and <code>b85fcb7</code> in the history of <code>dev4</code></p>

<p><strong>Plain merge </strong></p>

<p><code>
git checkout dev2
git merge dev3
</code></p>

<p><img src="/media/pic2014/0317-4.png" alt="git plain merge" /></p>

<p>Now <code>dev4</code> and <code>dev2</code> have the same content, but we cannot see <code>dev4</code> contains commits form <code>dev3</code>, but <code>dev2</code> has the information.</p>

<p><strong> Conclusion </strong></p>

<p><code>--squash</code> will abandon the merge history, so you will not know what was merged. Only use it when you don't want these commit history!</p>

<hr />

<h3>Rebase</h3>

<p><code>git rebase</code> acts like automatically <code>cherrypick</code> commits into current branch and then reapply the commits in current branch. See below example.</p>

<p><strong> Before rebase </strong></p>

<p><img src="/media/pic2014/0317-0.png" alt="Before rebase" /></p>

<p><strong> rebase </strong></p>

<p><code>
git checkout dev
git rebase master
</code></p>

<p><strong> After rebase </strong></p>

<blockquote><p>Notice: dev commit ccd4673 changed to 9d76e0b</p></blockquote>

<p><img src="/media/pic2014/0317-1.png" alt="After rebase" /></p>

<p><strong> Conclusion</strong></p>

<p>Rebase do not like merge - which will cause a commit, and from the tree you cannot see when the dev is split out and when it is merged back. - So Linus calls it is a <em>clean</em> for history.</p>
]]></content:encoded>
    </item>
    
    <item>
      <title>发明人Linus Torvalds给出的Git使用建议</title>
      <link href="http://whiteear.github.io//2014/02/Linus-Torvalds-rules-for-using-Git/"/>
      <pubDate>2014-02-28T00:00:00+08:00</pubDate>
      <author>whiteear</author>
      <guid>http://whiteear.github.io//2014/02/Linus-Torvalds-rules-for-using-Git</guid>
      <content:encoded><![CDATA[<blockquote><p><strong>导读</strong></p>

<ul>
<li>博主自己大约花了二十分钟用来阅读本文，如果你时间不够，请先收藏。</li>
<li>本文分为两部分，第一部分较为概略，一般要读到第二部分时才能明白前面说的是什么。</li>
<li>本文精彩的论述了什么时候用rebase，什么时候不能用。同时分析了使用Pull,Merge,Push的时机。</li>
</ul>
</blockquote>

<h3>引言</h3>

<p>如何更好的使用Git？作为Git的发明人Torvalds会给出什么样的建议呢？
<a href="http://torvalds-family.blogspot.sg/">Linus Torvalds的博客</a>和他的Mail list里提到过使用Git的一些注意事项。（该Blog可能国内被墙）</p>

<p>现在开始挖坟啦！话说2009年的某一天Linux 2.6.31内核的分枝合并工作进行的很顺利（你知道现在Linux内核的版本号吗？），Torvalds的心情大好于是就写下一篇与Git有一点点关系的<a href="http://torvalds-family.blogspot.sg/2009/06/happiness-is-warm-scm.html">blog</a>，然后后面有两个人在回复里问Git应该怎么用呢？</p>

<h3>问题</h3>

<blockquote><p>As a Git n00b, would be nice to see a post on what these "rules that work" are.</p></blockquote>

<p>Linus Torvalds刚好心情大好就给整理了一下。</p>

<h3>Linus回答</h3>

<p>It's basically a matter of finding the right balance on a couple of different axises:</p>

<p>"clean history":</p>

<p>Balancing the need to clean up after mistakes (aka "rewriting history") using tools like 'git rebase', but then not doing it so much that you actually rewrite other peoples commits or lose all sight of the important history (like the fact that you tested one particular test, and if you then rewrite the history, all your testing is now dubious).</p>

<p>"Merging too much vs too little":</p>

<p>Merging is nice, because if you have concurrent development, a merge will tie the two branches together and allows you to test and develop on top of both changes.</p>

<p>But the downside is that merging too eagerly means that two separate branches that are for two different features are now tied together, and you can never separate the two (at least without re-doing the whole history).</p>

<p>So merging too much results in a very messy history, where you can't see what the actual different "topics" were. And it results in a tree where upstream (that is - me) can't review and pull the features one by one.</p>

<p>There's a few rants and rules about this that I did on the mailing lists last merge window. See for example <a href="http://www.mail-archive.com/dri-devel@lists.sourceforge.net/msg39091.html">rant</a></p>

<h3>另一个Mail List里的意见</h3>

<p>上面写的有些概括，这里其实是对上文的解释。</p>

<h3>邮件上下文</h3>

<blockquote><p>My plans from now on are just to send you non-linear trees, whenever I
merge a patch into my next tree thats when it stays in there, I'll pull
Eric's tree directly into my tree and then I'll send the results, I
thought we cared about a clean merge history but as I said without some
document in the kernel tree I've up until now had no real idea what you
wanted.</p></blockquote>

<h3>Linus回答</h3>

<blockquote><p>注意Linus的原文就是用<em>Markdown</em>格式写的，下面是原文，我没有加入任何Markdown格式。说明Linus在写邮件的时候是极为注意细节的。大家可以去查看<a href="http://www.mail-archive.com/dri-devel@lists.sourceforge.net/msg39091.html">原文的Raw格式</a> <br/>
另外如果下文提到的<em>rebase</em>你不是特别清楚的话，请参考:<a href="http://http://blog.sevenche.com/2014/03/Git_merge_--squash_and_git_rebase/">git merge --squash and git rebase explained</a></p></blockquote>

<p>I want clean history, but that really means (a) clean and (b) history.</p>

<p>People can (and probably should) rebase their <em>private</em> trees (their own
work). That's a <em>cleanup</em>. But never other peoples code. That's a "destroy
history"</p>

<p>So the history part is fairly easy. There's only one major rule, and one
minor clarification:</p>

<ul>
<li><p>You must never EVER destroy other peoples history. You must not rebase
commits other people did. Basically, if it doesn't have your sign-off
on it, it's off limits: you can't rebase it, because it's not yours.</p>

<p>Notice that this really is about other peoples <em>history</em>, not about
other peoples <em>code</em>. If they sent stuff to you as an emailed patch,
and you applied it with "git am -s", then it's their code, but it's
<em>your</em> history.</p>

<p>So you can go wild on the "git rebase" thing on it, even though you
didn't write the code, as long as the commit itself is your private
one.</p></li>
<li><p>Minor clarification to the rule: once you've published your history in
some public site, other people may be using it, and so now it's clearly
not your <em>private</em> history any more.</p>

<p>So the minor clarification really is that it's not just about "your
commit", it's also about it being private to your tree, and you haven't
pushed it out and announced it yet.</p></li>
</ul>


<p>That's fairly straightforward, no?</p>

<p>Now the "clean" part is a bit more subtle, although the first rules are
pretty obvious and easy:</p>

<ul>
<li><p>Keep your own history readable</p>

<p>Some people do this by just working things out in their head first, and
not making mistakes. but that's very rare, and for the rest of us, we
use "git rebase" etc while we work on our problems.</p>

<p>So "git rebase" is not wrong. But it's right only if it's YOUR VERY OWN
PRIVATE git tree.</p></li>
<li><p>Don't expose your crap.</p>

<p>This means: if you're still in the "git rebase" phase, you don't push
it out. If it's not ready, you send patches around, or use private git
trees (just as a "patch series replacement") that you don't tell the
public at large about.</p></li>
</ul>


<p>It may also be worth noting that excessive "git rebase" will not make
things any cleaner: if you do too many rebases, it will just mean that all
your old pre-rebase testing is now of dubious value. So by all means
rebase your own work, but use <em>some</em> judgement in it.</p>

<p>NOTE! The combination of the above rules ("clean your own stuff" vs "don't
clean other peoples stuff") have a secondary indirect effect. And this is
where it starts getting subtle: since you most not rebase other peoples
work, that means that you must never pull into a branch that isn't already
in good shape. Because after you've done a merge, you can no longer rebase
you commits.</p>

<p>Notice? Doing a "git pull" ends up being a synchronization point. But it's
all pretty easy, if you follow these two rules about pulling:</p>

<ul>
<li><p>Don't merge upstream code at random points.</p>

<p>You should <em>never</em> pull my tree at random points (this was my biggest
issue with early git users - many developers would just pull my current
random tree-of-the-day into their development trees). It makes your
tree just a random mess of random development. Don't do it!</p>

<p>And, in fact, preferably you don't pull my tree at ALL, since nothing
in my tree should be relevant to the development work <em>you</em> do.
Sometimes you have to (in order to solve some particularly nasty
dependency issue), but it should be a very rare and special thing, and
you should think very hard about it.</p>

<p>But if you want to sync up with major releases, do a</p>

<pre><code> git pull linus-repo v2.6.29
</code></pre>

<p>or similar to synchronize with that kind of <em>non_random</em> point. That
all makes sense. A "Merge v2.6.29 into devel branch" makes complete
sense as a merge message, no? That's not a problem.</p>

<p>But if I see a lot of "Merge branch 'linus'" in your logs, I'm not
going to pull from you, because your tree has obviously had random crap
in it that shouldn't be there. You also lose a lot of testability,
since now all your tests are going to be about all my random code.</p></li>
<li><p>Don't merge <em>downstream</em> code at random points either.</p>

<p>Here the "random points" comment is a dual thing. You should not mege
random points as far as downstream is concerned (they should tell you
what to merge, and why), but also not random points as far as your tree
is concerned.</p>

<p>Simple version: "Don't merge unrelated downstream stuff into your own
topic branches."</p>

<p>Slightly more complex version: "Always have a <em>reason</em> for merging
downstream stuff". That reason might be: "This branch is the release
branch, and is <em>not</em> the 'random development' branch, and I want to
merge that ready feature into my release branch because it's going to
be part of my next release".</p></li>
</ul>


<p>See? All the rules really are pretty simple. There's that somewhat subtle
interaction between "keep your own history clean" and "never try to clean
up <em>other</em> proples histories", but if you follow the rules for pulling,
you'll never have that problem.</p>

<p>Of course, in order for all this to work, you also have to make sure that
the people you pull <em>from</em> also have clean histories.</p>

<p>And how do you make sure of that? Complain to them if they don't. Tell
them what they should do, and what they do wrong. Push my complaints down
to the people you pull from. You're very much allowed to quote me on this
and use it as an explanation of "do this, because that is what Linus
expects from the end result".</p>

<pre><code>                    Linus
</code></pre>

<h3>总结</h3>

<p>Linus特别注意提交历史的干净与可读，其中给出了rebase应该的使用场境。</p>

<blockquote><p>附本文相关文章--<a href="http://blog.sevenche.com/2014/02/Git-%E5%AD%A6%E4%B9%A0%E8%B7%AF%E7%BA%BF%E5%9B%BE%E5%8F%8A%E4%B8%AD%E6%96%87%E8%B5%84%E6%96%99%E6%8E%A8%E8%8D%90/">Git-学习路线图及中文资料推荐</a></p></blockquote>
]]></content:encoded>
    </item>
    
    <item>
      <title>如何在Linux下实现QoS</title>
      <link href="http://whiteear.github.io//2014/02/Implement-QoS-On-Iptables/"/>
      <pubDate>2014-02-28T00:00:00+08:00</pubDate>
      <author>whiteear</author>
      <guid>http://whiteear.github.io//2014/02/Implement-QoS-On-Iptables</guid>
      <content:encoded><![CDATA[<p>QoS本身是一个比较大的话题，但是毫无疑问，对于音频，视频应用来说QoS的作用是巨大的。有工程师跟我说过在实施时加不加QoS有很大的差别。这里特别提醒一下QoS要在网络的所有结点上启用才能发挥最大效果（结点包括，路由器，服务器等），最起码也要保证加在比较繁忙的结点上，不然没有多大意义。
下面是在Linux服务器上通过iptables给相关端口加上高优先级的脚本。大家可以举一反三给特定的IP包加上优先级。</p>

<p>```</p>

<p>LOGFILE=/tmp/logs/iptables.log
SERVICE=<code>which service</code>
IPTABLES_STATUS=<code>$SERVICE iptables status 2&gt; /dev/null | head -n 1</code>
if [ <code>rpm -qa iptables|grep -c iptables</code> -eq 0 -o -z "$IPTABLES_STATUS" ]; then
   echo <code>date +"%F %T"</code> " - IPTABLES NOT INSTALLED!! QoS NOT SET!!\n" >> $LOGFILE
   exit 1
fi
if [ <code>echo "$IPTABLES_STATUS" | grep -c stopped</code> -gt 0 ]; then
   echo <code>date +"%F %T"</code> " - IPTABLES is stopped and will be started!\n" >> $LOGFILE
fi</p>

<p>IPTABLES="$(which iptables)"</p>

<h1>RESET DEFAULT POLICIES</h1>

<p>$IPTABLES -P INPUT ACCEPT
$IPTABLES -P FORWARD ACCEPT
$IPTABLES -P OUTPUT ACCEPT
$IPTABLES -t nat -P PREROUTING ACCEPT
$IPTABLES -t nat -P POSTROUTING ACCEPT
$IPTABLES -t nat -P OUTPUT ACCEPT
$IPTABLES -t mangle -P PREROUTING ACCEPT
$IPTABLES -t mangle -P OUTPUT ACCEPT</p>

<h1>FLUSH ALL RULES, ERASE NON-DEFAULT CHAINS</h1>

<p>$IPTABLES -F
$IPTABLES -X
$IPTABLES -t nat -F
$IPTABLES -t nat -X
$IPTABLES -t mangle -F
$IPTABLES -t mangle -X</p>

<h1>ADD QoS RULES</h1>

<p>$IPTABLES -t mangle -A OUTPUT -p tcp --sport 1935 -j DSCP --set-dscp 0x22
$IPTABLES -t mangle -A OUTPUT -p tcp --sport 443 -j DSCP --set-dscp 0x22
$IPTABLES -t mangle -A OUTPUT -p tcp --sport 5060 -j DSCP --set-dscp 0x22
$IPTABLES -t mangle -A OUTPUT -p tcp --sport 5061 -j DSCP --set-dscp 0x22
$IPTABLES -t mangle -A OUTPUT -p tcp --dport 5060 -j DSCP --set-dscp 0x22
$IPTABLES -t mangle -A OUTPUT -p tcp --dport 5061 -j DSCP --set-dscp 0x22</p>

<p>echo "<strong><strong><strong>" <code>date +"%F %T"</code> "</strong></strong></strong>" >> $LOGFILE
$SERVICE iptables save >> $LOGFILE
echo "$IPTABLES -t mangle -L" >> $LOGFILE
<code>``   
其原理非常简单，就是给所有通过某端口的包加上(</code>mangle<code>)特定标志(</code>dscp 0x22<code>)，这样经过的节点只要支持QoS都会给于相应的优先级。脚本中的</code>dscp 0x22<code>是针对Avaya和北电的产品的，不同厂商的产品可能使用不同的数字，请参考单独的页面介绍[Notes on QOS for videoconferencing](http://andrew.triumf.ca/vidconf_QOS.html)。加完后你的</code>ipdables`看起来应该是这个样子。然后你的包就会优先被处理了。</p>

<p>```
Chain POSTROUTING (policy ACCEPT)
target     prot opt source               destination</p>

<hr />

<p><strong><strong><strong> 2013-11-27 16:06:20 </strong></strong></strong>
iptables: Saving firewall rules to /etc/sysconfig/iptables: ESC[60G[ESC[0;32m  OK  ESC[0;39m]
/sbin/iptables -t mangle -L
Chain PREROUTING (policy ACCEPT)
target     prot opt source               destination</p>

<p>Chain INPUT (policy ACCEPT)
target     prot opt source               destination</p>

<p>Chain FORWARD (policy ACCEPT)
target     prot opt source               destination</p>

<p>Chain OUTPUT (policy ACCEPT)
target     prot opt source               destination
DSCP       tcp  --  anywhere             anywhere            tcp spt:macromedia-fcs DSCP set 0x22
DSCP       tcp  --  anywhere             anywhere            tcp spt:https DSCP set 0x22
DSCP       tcp  --  anywhere             anywhere            tcp spt:sip DSCP set 0x22
DSCP       tcp  --  anywhere             anywhere            tcp spt:sip-tls DSCP set 0x22
DSCP       tcp  --  anywhere             anywhere            tcp dpt:sip DSCP set 0x22
DSCP       tcp  --  anywhere             anywhere            tcp dpt:sip-tls DSCP set 0x22</p>

<p>Chain POSTROUTING (policy ACCEPT)
target     prot opt source               destination
```</p>
]]></content:encoded>
    </item>
    
    <item>
      <title>Git-学习路线图及中文资料推荐</title>
      <link href="http://whiteear.github.io//2014/02/Git-%E5%AD%A6%E4%B9%A0%E8%B7%AF%E7%BA%BF%E5%9B%BE%E5%8F%8A%E4%B8%AD%E6%96%87%E8%B5%84%E6%96%99%E6%8E%A8%E8%8D%90/"/>
      <pubDate>2014-02-18T00:00:00+08:00</pubDate>
      <author>whiteear</author>
      <guid>http://whiteear.github.io//2014/02/Git-学习路线图及中文资料推荐</guid>
      <content:encoded><![CDATA[<blockquote><p>人生若只如初见，所有往事都化为江南的一场烟雨，在相视一笑中，随风荡漾起回忆的波纹，然后再渐渐隐去在画中的江南，只因为你的离去，我竟为你留下的惊艳 ...</p></blockquote>

<p>本文针对那些对GIT有<strong>初见</strong>感觉的攻城狮们。</p>

<hr />

<p><img src="/media/pic2014/0218-0.png" alt="" /></p>

<h2>引子</h2>

<p>一开始GIT给人感觉很简单，但一用起来又觉得每个地方都捉襟见肘。其实git的学习曲线要比想象中的更为陡峭，有近20个常用命令，每个命令又有20个左右常用的参数，相互组合使用。要学好的话学习量绝对不低于新学一门语言和其常用类库，因其大多数操作都有相近的实现方式，但结果又各不相同，所以蒋薪的《git权威指南》才写了595页。可是很多人并不喜欢大部头通读的方式，而更便爱边用边学。所幸git除官方文档外还有众多开源文档，其中比较著名的文档都有中文翻译。高质量的中文文档的阅读更高效，这里就是我note里收集的一些相关网络书籍，以由易向难的顺序介绍。</p>

<hr />

<h2>入门级</h2>

<h3><a href="http://zh.wikipedia.org/wiki/Git">Git的维基定义</a></h3>

<p>为什么要叫GIT? 作为Linux创始人Torvalds的大作，不了解它的历史总有点说不过去。</p>

<h3><a href="http://rogerdudler.github.io/git-guide/index.zh.html">git - 简易指南</a></h3>

<p>图文并貌，大名鼎鼎，无数的人就是看了这篇文章后觉得GIT挺好用呀，然后，然后就掉坑里了。</p>

<hr />

<h2>初级到中级</h2>

<p>这个时候首先你要有一个练习用的GIT库，还得拿那个库干点事。推荐在github.com注册个账号建一个练习库，然后在本地克隆两份，用来模拟两个程序员之间的同步和练习下面推荐教程中的命令。</p>

<h3><a href="http://git-scm.com/book/zh">PRO GIT</a></h3>

<p>本书具有一定的官方性质，是正式出版物的免费版，学习Git的屠龙刀。其深入浅出，长度适中，讲解精练到位，结构合理，通读此书是提升功力的捷径。</p>

<h3><a href="http://marklodato.github.io/visual-git-guide/index-zh-cn.html">图解Git</a></h3>

<p>真是一图胜千言，在众多文档中此文可以算是出奇制胜，其它文档中较难理解的东西到了这里迎刃而解，称之为倚天剑毫不过分。倚天配屠龙 - 可在读'Pro Git'时配套用。</p>

<h3><a href="http://www-cs-students.stanford.edu/~blynn/gitmagic/intl/zh_cn/ch02.html">Git Magic</a></h3>

<p>斯坦福血统，内容覆盖广，但解释偏少，可在读完'Pro Git'之后用来开拓思路。</p>

<h3><a href="http://gitbook.liuhui998.com/index.html">Git Community Book 中文版</a></h3>

<p>因为程度上本书和'Pro Git'冲突，本人没有读过此书，但仅看其完整的体系结构和中文翻译是值得推荐的。</p>

<h3><a href="http://www.ruanyifeng.com/blog/2012/07/git.html">Git分支管理策略</a></h3>

<p>了解branch指令是一回事，怎么管理这些branch又是另一回事。'Pro Git'有分支管理的章节，不过没有这里说的详细。</p>

<h3>GitHub相关</h3>

<p>相信不少人在学习GIT的过程中都有在Github上建blog的冲动，下面是一些对Github不错的介绍。搭建Blog本身也是一个GIT学习和使用的过程。<br/>
<a href="http://www.yangzhiping.com/tech/github.html">如何高效利用GitHub</a>  <br/>
<a href="http://www.worldhello.net/gotgithub/">蒋薪-GitHub</a><br/>
上文的作者'蒋薪'正是那本595页《git权威指南》的作者。</p>

<h3>其它</h3>

<p><a href="http://blog.gogojimmy.net/2012/01/17/how-to-use-git-1-git-basic/">Git 教學</a> <br/>
三篇繁体中文，优点在于有图示。</p>

<p><a href="http://blackanger.blog.51cto.com/140924/123399">Git中级用法</a> <br/>
排版不是很好，但GIT中比较关键的地方讲的不错，开扩视野用吧。</p>

<h3><a href="http://git-scm.com/downloads/guis">Git GUI Clients</a></h3>

<p>为了本文的完整性加进来的英文页面，好在这不是教材，无伤大雅。</p>

<h3><a href="http://blog.sevenche.com/2014/02/Git-cook-book/">Git Cookbook</a></h3>

<p>这是本人的作品哈，里面是一些有用的小技巧。比如说你一上手拿到一个3G大小的库，众多的分支，怎么开始工作？</p>

<hr />

<h2>高级阶段</h2>

<p>看书是到不了这个阶段的，只有靠自己修行了。这个时候的老师就一个～谷哥。</p>

<blockquote><p>题外的一点感悟，众多的提交历史和方便的Diff功能使得GIT库成为一个学习的宝库。比如作者一上来拿到一个3G的库，几乎没有文档，先自己跟据分支的历史找到常用的分支。想知道一个功能怎么实现的就grep提交历史，找到相关提交后再diff一下就什么都清楚了，比在IDE里查的还快。</p></blockquote>
]]></content:encoded>
    </item>
    
    <item>
      <title>《高效能人士的七个习惯》读后感</title>
      <link href="http://whiteear.github.io//2014/02/Seven-Habits-After-Read/"/>
      <pubDate>2014-02-06T00:00:00+08:00</pubDate>
      <author>whiteear</author>
      <guid>http://whiteear.github.io//2014/02/Seven-Habits-After-Read</guid>
      <content:encoded><![CDATA[<h3>简介</h3>

<hr />

<p>这里有本书的一个详细的<a href="http://baike.baidu.com/link?url=zBc7rQB2Us-Z2tuFvTaxdsasSSoWuRwyXynXJbEegTGIprxJC6ruWaYZGNMg83gy">百度百科介绍</a></p>

<h3>远不止七个习惯</h3>

<hr />

<p>一般来说，近期社科类的书中标题党比较多，只要浏览一下标题和第一章，整本书就不用看了。应该说高效能人士的七个习惯还是比较有货的，全书的内容用七个习惯来概括，但整本书有一个完整的理论体系，从任务管理到社交，各个分散的要点都是整体的一部分，每一部分都有自我评分表使得评估与改进可以量化。</p>

<h3>关注第二类任务</h3>

<hr />

<p>无论如何有货，这一类型的书总是类似的，不可能处处是创新。个人于本书的唯一的收获在于关于任务优先级的一段论述。日常工作任务被分成4类。</p>

<ul>
<li>第一类是必须按时交付的KPI与紧急任务之类。</li>
<li>第二类是有助于生产力提高但不在考核之列的，比如自我提升，人际关系等。</li>
<li>第三类是非重点的次要任务。</li>
<li>第四类是休闲之类。</li>
</ul>


<p>该书提出仅仅把工作重心放在第一类是远不够的，第二类往往被人忽视，这导致人们总是疲于奔命。但是高效能人士总是未雨绸缪，第二类任务才是他们关注的重点。想想看这个规则解释了为什么公司里的老黄牛并不是职业发展最好的。作为程序员，总有敲不完的代码，但总归还是要拿出时间学习新东西，才能跟得上发展。会的不难，知识积累上去了，产出自然会提高，对于知识型员工这一点尤为重要。回想因为兴趣自己去年用了很多业余时间学git，好像与工作没有什么关系，但是突然就遇到一个项目，其有2G大小的代码库，之前学的看似无用的东西一下发挥了价值。试想一下等到开发任务来的时候还要再学git该有多大的压力。</p>

<p>谷歌给员工20％的时间自由支配，似乎正好暗合了这一点。</p>
]]></content:encoded>
    </item>
    
    <item>
      <title>Adobe Air App跑在Android上的兼容性问题</title>
      <link href="http://whiteear.github.io//2014/02/Air-Application-Debug-in-Android/"/>
      <pubDate>2014-02-06T00:00:00+08:00</pubDate>
      <author>whiteear</author>
      <guid>http://whiteear.github.io//2014/02/Air-Application-Debug-in-Android</guid>
      <content:encoded><![CDATA[<blockquote><p>这一两个月又把Flash Builder捡起来做了一段时间的Air开发。要求Air APP要能同时运行在PC, Android上。遇到兼容性问题现在全部解决。</p></blockquote>

<h3>Input控件不能输入中文</h3>

<p>解决之道，在FB的编译选项里有一个Language的参数，删除就行了。</p>

<h3>APP的视频在某平板上不能显示H.264的视频</h3>

<p>花了一个多星期才搞定，各种Debug。最终发现是Air Runtime版本的问题。Android Market上只有最新版的Air，到哪里才能找到不同的版本呢？经过一番查找，最终在联想的乐商店找到了各种历史版本，然后一个个的试，终于Air 3.1上跑出来了。</p>

<h3>关于Air Runtime的Tips:</h3>

<ul>
<li>TIP 1</li>
</ul>


<p>由于Air的版本不停更新，如何保证在旧版上测试并发布过的APP在用户更新了Air Runtime后不会出兼容问题呢？答案是使用<code>Apk-captive-runtime</code>编译参数。示例如下：</p>

<p><code>
adt -package -target apk‑captive‑runtime -storetype pkcs12 -keystore SigningCert_test.p12 InStoreApp.apk InStoreApp-app.xml InStoreApp.swf icons res Default.png
</code>
这个参数的作用是把Air Runtime绑定在APK中，这样不用用户去单独安装Air，即使用户安装了其它的版本也不会被用到。</p>

<ul>
<li>TIP 2</li>
</ul>


<p>AIR的SDK目前是3.9，但FB 4.7中自带的还是3.1。如何在FB中升级或切换使用不同的AIR　SDK？官方有如下两篇文档，但是没说清楚反而误导群众。</p>

<blockquote><p><a href="http://helpx.adobe.com/flash-builder/kb/overlay-air-sdk-flash-builder.html">http://helpx.adobe.com/flash-builder/kb/overlay-air-sdk-flash-builder.html</a></p>

<p><a href="http://helpx.adobe.com/flash-builder/kb/overlay-air-sdk-flash-builder.html">http://helpx.adobe.com/x-productkb/multi/how-overlay-air-sdk-flex-sdk.html</a></p></blockquote>

<p>需要补充的是，我们要下载<strong>两个不同版本</strong>的AIR　SDK，分别覆盖不同的文件目录（Flex SDK，和Plugin）。之前一定要<strong>做好备份</strong>。</p>
]]></content:encoded>
    </item>
    
    <item>
      <title>Git Cookbook</title>
      <link href="http://whiteear.github.io//2014/02/Git-cook-book/"/>
      <pubDate>2014-02-03T00:00:00+08:00</pubDate>
      <author>whiteear</author>
      <guid>http://whiteear.github.io//2014/02/Git-cook-book</guid>
      <content:encoded><![CDATA[<blockquote><p>本文始于自己的Evernote，由于大部分原本是英文记录的，所以干脆全部用英文。</p>

<p>Most of the content comes from my Evernote, therefore, this post will be updated once I have more notes, and you are highly welcome to contribute your notes to this article or point out any mistake.</p></blockquote>

<h3>How to see simple git log?</h3>

<hr />

<p>The following let you to see only one line comment for each commit.</p>

<p><code>
git log --oneline
git log --oneline -3
</code>
Below command let you to display Gitk-alike tree to your shell screen. And <code>--global alias.pl</code> allows you to use the short form of command. like <code>$ git pl</code>.</p>

<p><code>
git log --oneline --graph --decorate
git config --global alias.pl "log --oneline --graph --decorate"
</code>
Usage:</p>

<p><img src="/media/pic2014/0203-1.png" alt="" /></p>

<h3>How to see log in another branch?</h3>

<hr />

<p><code>shell
git log origin/master..
</code></p>

<h3>How to search keywords in commit comment (across all branches)?</h3>

<hr />

<p>If you want to know how a feature was implemented you can start by search the keywords in the log history and then diff it. From my experience, most of times this method is faster than search in the IDE.</p>

<p><code>
git log --all --grep='a keyword'
</code>
<strong>Note</strong>
<code>--grep</code> can bring you the entire commit message instead of ONE line which contains the keywords. This command is better than the shell <code>grep</code> command <code>git log --all |grep 'keyword'</code> because the later only gives you one line result and you cannot see ALL comment of a commit.</p>

<h3>How to see history of one file?</h3>

<hr />

<p>You have many options to achieve that goal.</p>

<p><code>
git log -- [filename] (show the log history)
git log -p filename (Diff the code; git generate the patches for each log entry)
gitk [filename] (Show the content changed)
git log --follow &lt;filename&gt; (Show rename)
</code></p>

<h3>How to only produce one commit for a merge?</h3>

<hr />

<p>Think about you have a dev branch and a main branch and you have a lot of commits in your dev branch, but when merge code you don't want all those comment history goes to the main branch(the main branch history could be more meaningful). use <code>--squash</code> to only produce one new commit for the merge.</p>

<p><code>
git merge --squash bugfix
git commit -m 'fix bug'
</code></p>

<h3>How to only see local commit log?</h3>

<hr />

<p>The following gives you two ways to see that.</p>

<p><code>
git log --no-merges master..
git log -g
</code></p>

<h3>How to revert to a commit?</h3>

<hr />

<p><code>
git reset --hard 4a155e5
and then
git push -f origin master
</code>
<strong>Notice</strong> git revert will not work here! <code>git revert</code> can only revert one commit. If you have commit <code>11,22,33,44,</code> and you <code>git revert 22</code> then you will have commit <code>11,33,44</code>, but if you <code>git reset --hard 22</code> and commit, then you could only have <code>11</code> in your commit history.</p>

<h3>How to find a lost commit?</h3>

<hr />

<p>Sometimes we could lost our commit(For example you are working on a detached HEAD). As a last resort in case your commit is dangling and not connected to history at all, you can search the reflog itself with the <code>-g</code> flag (short for <code>--walk-reflogs</code>)</p>

<p><code>
git log -g --grep='Build 0051'
</code>
<strong>This is because that the reflog contains the local history.</strong>
After you get the SHA-1 for you commit. You can check it out.</p>

<h3>How to know which branch is the most recent?</h3>

<hr />

<p>Once you cloned a huge repo, and a lot of branch can be found within it - some of them are not active because the feature development was completed. How to know which branch to use? My way is to sort these branches by commit time, so we know which branch is fresh.</p>

<p><code>
git config --global alias.latest "for-each-ref --sort=-committerdate --format='%(committerdate:short) %(refname:short)'"
</code></p>

<p><strong>Usage:</strong></p>

<p>```
$ cd ~/Code/rails/rails &amp;&amp; git latest
2012-11-19 origin/master
2012-11-19 origin/HEAD
2012-11-19 master
2012-11-19 origin/3-2-stable
2012-11-03 origin/encrypted_cookies
2012-11-03 origin/attributes_perf
... snipped ...</p>

<p>```
Show local branches only:</p>

<p><code>
git config --global alias.latest "for-each-ref --sort=-committerdate refs/heads --format='%(committerdate:short) %(refname:short)'"
</code></p>

<h3>How to change the remote HEAD</h3>

<hr />

<p>```
git branch -a
remotes/origin/HEAD -> origin/gh-pages
remotes/origin/gh-pages
remotes/origin/master</p>

<p>git remote set-head origin master
git branch -a
remotes/origin/HEAD -> origin/master
remotes/origin/gh-pages
remotes/origin/master
```</p>

<h3>How to delete a remote git branch?</h3>

<hr />

<p><code>
git push origin --delete &lt;branchName&gt;
</code></p>

<h3>How to delete the merge orig file?</h3>

<hr />

<p>Some automatically generated <code>*.orig</code> files will be left in your working folder after a successful merge. One quick way to delete them could be</p>

<p><code>
git clean -f
</code></p>

<p><strong>Beware</strong> There's no going back. Use <code>-n</code> or <code>--dry-run</code> to preview the damage you'll do.
 <code>git-clean</code>  Remove untracked files from the working tree
If you want to also remove directories, run <code>git clean -f -d</code>
If you just want to remove ignored files, run <code>git clean -f -X</code>
If you want to remove ignored as well as non-ignored files, run <code>git clean -f -x</code>
Note the case difference on the X for the two latter commands.</p>

<h3>How to know the remote branch names?</h3>

<hr />

<p>OK, you got a huge repository, maybe the first step is to know the remote branch names.</p>

<p><code>
git branch -r
</code></p>

<h3>How to rename a file?</h3>

<p><code>
$ git mv README README.md
$ git commit -m "renamed"
$ git push origin master
</code></p>

<h3>How to pull a remote branch?</h3>

<hr />

<p>Before you can start working locally on a remote branch, you need to fetch it as called out in answers below.
To fetch a branch, you simply need to:</p>

<p><code>
git fetch origin
git branch -r
</code></p>

<p>This will fetch all of the remote branches for you. With the remote branches in hand, you now need to check out the branch you are interested in, giving you a local working copy:</p>

<p><code>
git checkout -b test origin/test
</code></p>
]]></content:encoded>
    </item>
    
  </channel>
</rss>
